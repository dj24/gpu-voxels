#pragma kernel CSMain

// RWByteAddressBuffer vertexBuffer;
RWStructuredBuffer<float3> vertexBuffer;
RWByteAddressBuffer normalBuffer;
RWByteAddressBuffer colourBuffer;
RWByteAddressBuffer indexBuffer;
ConsumeStructuredBuffer<uint4> faceBuffer;

Texture3D<float4> inputTexture;

void Store(RWByteAddressBuffer buf, int index, float3 v)
{
    uint3 data = asuint(v);
    buf.Store3((index * 3)<<2, data);
}

uint GetVertexIndex(uint vIndex, uint tri){
    uint2x3 indices = {
        0, 1, 2,
        1, 3, 2,
    };
    return indices[tri][vIndex];
}

float3 GetNormal(uint faceIndex){
    switch(faceIndex){
        case 0:
        {
            return float3(0,1,0); // up
            break;
        }
        case 1:
        {
            return float3(0,-1,0); // down
            break;
        }
        case 2:
        {
            return float3(1,0,0); //right
            break;
        }
        case 3:
        {
            return float3(-1,0,0); // left
            break;
        }
        case 4:
        {
            return float3(0,0,1); // forward
            break;
        }
        case 5:
        {
            return float3(0,0,-1); // back
            break;
        }
    }
    return float3(0,0,0);
}

float4x3 GetVertices(uint faceIndex){
    float4x3 vertices = {
        0, 0, 0,
        0, 0, 0,
        0, 0, 0,
        0, 0, 0
    };
    switch(faceIndex){
        case 0:
        {
            vertices[0] = float3(0, 1, 0);
            vertices[1] = float3(0, 1, 1);
            vertices[2] = float3(1, 1, 0);
            vertices[3] = float3(1, 1, 1);
            break;
        }
        case 1:
        {
            vertices[0] = float3(0, 0, 0);
            vertices[1] = float3(1, 0, 0);
            vertices[2] = float3(0, 0, 1);
            vertices[3] = float3(1, 0, 1);
            break;
        }
        case 2:
        {
            vertices[0] = float3(1, 0, 0);
            vertices[1] = float3(1, 1, 0);
            vertices[2] = float3(1, 0, 1);
            vertices[3] = float3(1, 1, 1);
            break;
        }
        case 3:
        {
            vertices[0] = float3(0, 0, 0);
            vertices[1] = float3(0, 0, 1);
            vertices[2] = float3(0, 1, 0);
            vertices[3] = float3(0, 1, 1);
            break;
        }
        case 4:
        {
            vertices[0] = float3(0, 0, 1);
            vertices[1] = float3(1, 0, 1);
            vertices[2] = float3(0, 1, 1);
            vertices[3] = float3(1, 1, 1);
            break;
        }
        case 5:
        {
            vertices[0] = float3(0, 0, 0);
            vertices[1] = float3(0, 1, 0);
            vertices[2] = float3(1, 0, 0);
            vertices[3] = float3(1, 1, 0);
            break;
        }
    }
    return vertices;
}

[numthreads(1,1,1)] // 2 tris per face, 6 faces per voxel
void CSMain (uint id : SV_DispatchThreadID){
    uint4 face = faceBuffer.Consume();
    uint3 voxelPosition = face.xyz;
    uint faceIndex = face.w;

    // if(inputTexture[voxelPosition].w <= 0){
    //     return;
    // }

    for(uint triIndex = 0; triIndex < 2; triIndex++){
        int id1 = id * 6;
        int id2 = id * 6 + 1;
        int id3 = id * 6 + 2;

        id1 += triIndex * 3;
        id2 += triIndex * 3;
        id3 += triIndex * 3;

        // Debug Colours
        float3 c = inputTexture[voxelPosition].xyz;

        // Get vertices based on face directions
        float3 n = GetNormal(faceIndex);
        float4x3 vertices = GetVertices(faceIndex);

        float3 v1 = voxelPosition + vertices[GetVertexIndex(0, triIndex)];
        float3 v2 = voxelPosition + vertices[GetVertexIndex(1, triIndex)];
        float3 v3 = voxelPosition + vertices[GetVertexIndex(2, triIndex)];

        // Store(vertexBuffer, id1, v1);
        // Store(vertexBuffer, id2, v2);
        // Store(vertexBuffer, id3, v3);
        vertexBuffer[id1] = v1;
        vertexBuffer[id2] = v2;
        vertexBuffer[id3] = v3;
        
        Store(normalBuffer, id1, n);
        Store(normalBuffer, id2, n);
        Store(normalBuffer, id3, n);

        Store(colourBuffer, id1, c);
        Store(colourBuffer, id2, c);
        Store(colourBuffer, id3, c);

        indexBuffer.Store((id1)<<2, id1);
        indexBuffer.Store((id2)<<2, id2);
        indexBuffer.Store((id3)<<2, id3);
    }
}
